package network.crypta.crypto

import dev.whyoleg.cryptography.CryptographyProvider
import dev.whyoleg.cryptography.DelicateCryptographyApi
import dev.whyoleg.cryptography.algorithms.AES
import kotlin.experimental.xor

/**
 * An implementation of [CryptoCipher] using the AES-CTR (Counter) mode with 256-bit keys.
 *
 * This class provides encryption and decryption capabilities based on the AES stream cipher mode.
 * In CTR mode, encryption and decryption are the same operation: XORing the data with a generated
 * keystream. The keystream is generated by encrypting a sequence of counter blocks.
 *
 * This implementation uses the `whyoleg-cryptography` library for the underlying AES operations.
 *
 * @property key The 32-byte (256-bit) raw key for AES encryption.
 * @constructor Creates an `AesCtrCipher` with the given key.
 */
internal class AesCtrCipher(key: ByteArray) : CryptoCipher {
    /**
     * The underlying AES-CTR cipher instance from the cryptography provider.
     *
     * @OptIn [DelicateCryptographyApi] is used because we are interacting with low-level
     * cryptographic primitives and raw keys.
     */
    @OptIn(DelicateCryptographyApi::class)
    private val ctr = run {
        val provider = CryptographyProvider.Default
        val aes = provider.get(AES.CTR)
        val aesKey = aes.keyDecoder().decodeFromByteArrayBlocking(AES.Key.Format.RAW, key)
        aesKey.cipher()
    }

    /**
     * The block size of AES, which is 16 bytes (128 bits).
     */
    private val blockSize = 16

    /**
     * A pre-allocated block of zeros used as input to generate the keystream.
     * In CTR mode, we encrypt the counter to produce a keystream block; the input data
     * itself is not used in the AES operation.
     */
    private val zeroBlock = ByteArray(blockSize)

    /**
     * Encrypts data using AES-CTR mode.
     * This is a one-shot operation that processes the entire [data] array.
     * A copy of the [iv] is made to prevent mutation of the caller's array.
     */
    override fun encrypt(iv: ByteArray, data: ByteArray): ByteArray = process(iv.copyOf(), data)

    /**
     * Decrypts data using AES-CTR mode.
     * In CTR mode, decryption is identical to encryption.
     * A copy of the [iv] is made to prevent mutation of the caller's array.
     */
    override fun decrypt(iv: ByteArray, data: ByteArray): ByteArray = process(iv.copyOf(), data)

    /**
     * Creates a stateful stream for AES-CTR encryption.
     * A copy of the [iv] is made to ensure the stream has its own mutable counter.
     */
    override fun encryptor(iv: ByteArray): CryptoCipherStream = CtrStream(iv.copyOf())

    /**
     * Creates a stateful stream for AES-CTR decryption.
     * In CTR mode, the decryption stream is identical to the encryption stream.
     * A copy of the [iv] is made to ensure the stream has its own mutable counter.
     */
    override fun decryptor(iv: ByteArray): CryptoCipherStream = CtrStream(iv.copyOf())

    /**
     * A stateful stream processor for AES-CTR mode.
     *
     * This inner class manages the state for chunk-based encryption/decryption, including
     * the current counter value and any buffered keystream data. It is not thread-safe.
     *
     * @property counter The current counter block, which is incremented for each block of keystream generated.
     */
    private inner class CtrStream(private val counter: ByteArray) : CryptoCipherStream {
        /**
         * A buffer for the currently generated keystream block.
         */
        private var keystream = ByteArray(0)

        /**
         * The current position (offset) within the [keystream] buffer.
         */
        private var pos = 0

        /**
         * Processes the next chunk of data.
         *
         * This method generates keystream blocks as needed, XORs them with the input data,
         * and returns the processed data. It internally manages a keystream buffer to handle
         * data chunks that are not aligned with the block size.
         *
         * @OptIn [DelicateCryptographyApi] is required for `encryptWithIvBlocking`.
         */
        @OptIn(DelicateCryptographyApi::class)
        override fun update(data: ByteArray, offset: Int, length: Int): ByteArray {
            val out = ByteArray(length)
            var off = 0
            while (off < length) {
                if (pos == keystream.size) {
                    keystream = ctr.encryptWithIvBlocking(counter, zeroBlock)
                    increment(counter)
                    pos = 0
                }
                val block = minOf(keystream.size - pos, length - off)
                for (i in 0 until block) {
                    out[off + i] = data[offset + off + i] xor keystream[pos + i]
                }
                pos += block
                off += block
            }
            return out
        }
    }

    /**
     * Performs one-shot AES-CTR processing for a full byte array.
     *
     * This is a helper function that encapsulates the core CTR logic used by both
     * one-shot encryption and decryption.
     *
     * @param counter The initial counter block (IV). This array will be mutated.
     * @param input The data to be processed (plaintext or ciphertext).
     * @return The processed data (ciphertext or plaintext).
     * @OptIn [DelicateCryptographyApi] is required for `encryptWithIvBlocking`.
     */
    @OptIn(DelicateCryptographyApi::class)
    private fun process(counter: ByteArray, input: ByteArray): ByteArray {
        val out = ByteArray(input.size)
        var keystream = ByteArray(0)
        var ksPos = 0 // Position within the current keystream block
        var pos = 0 // Position within the input/output data
        while (pos < input.size) {
            // If the keystream buffer is exhausted, generate a new block.
            if (ksPos == keystream.size) {
                keystream = ctr.encryptWithIvBlocking(counter, zeroBlock)
                increment(counter)
                ksPos = 0
            }

            // Determine how many bytes to process in this iteration.
            val block = minOf(keystream.size - ksPos, input.size - pos)

            // XOR the input data with the keystream.
            for (i in 0 until block) {
                out[pos + i] = input[pos + i] xor keystream[ksPos + i]
            }
            ksPos += block
            pos += block
        }
        return out
    }

    /**
     * Increments the counter byte array by one, treating it as a big-endian integer.
     *
     * This is the standard method for advancing the counter in CTR mode. It handles
     * wrap-around (carry) from one byte to the next.
     *
     * @param counter The counter block to increment in-place.
     */
    private fun increment(counter: ByteArray) {
        for (i in counter.lastIndex downTo 0) {
            val v = (counter[i].toInt() + 1) and 0xFF
            counter[i] = v.toByte()
            if (v != 0) break
        }
    }
}
